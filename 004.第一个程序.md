以前我们都是在debug中写汇编命令，在debug中运行。

现在我们将开始编写完整的汇编语言程序，用编译和连接程序将他们编译连接成为可执行文件，在操作系统中运行。



汇编语言程序从写出到最终执行的简要过程

第一步：编写汇编源程序

第二步：对源程序进行编译连接

使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件，再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件。

可执行程序包含两部分内容

1.程序：从源程序中汇编指令翻译过来的机器码。数据：源程序中定义的数据。

2.相关的描述信息，比如程序有多大，要占用多少内存空间。

第三部：在操作系统中执行可执行文件中程序

操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载如内存，并进行相关的初始化（比如设置CS:IP 指向第一条要执行的指令），然后由CPU执行程序



```assembly
assume cs:codesg

codesg segment
	mov ax,0123H
	mov bx,0456H
	add ax,bx
	add ax,ax
	
	mov ax,4c00H
	int 21H
	
codesg ends

end
```









 在汇编语言源程序中，包含两个指令 

1.汇编指令

2:伪指令



汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU执行。

伪指令没有对应的机器指令，不被CPU执行，由编译器来执行，编译器根据伪指令来进行相关的编译工作。

codesg segment   和  codesg ends  是伪指令，指明一个段的内容。codesg代表代码段。

assume cs：codesg 将用作代码段的段codesg和CPU中的段寄存器cs相关联。



一个汇编程序是由多个段组成，这些段被用来存放代码，数据或者当成栈空间来使用。

一个源程序中所有被计算机所处理的信息：指令，数据，栈，被划分到不同的段中。



  end 指明汇编程序的结束标记。当遇到该伪指令时，结束对源程序的编译。

assume  假设的意思，它假设某一段寄存器和程序中的某一个用segment..ends定义的段相关联。

通过assume说明这种关联，编译程序可以将段寄存器和某一个具体的段相联系。

![1571302057001](E:\github\JVM\images\1571302057001.png)

codesg在segment的前面，作为一个段的名称，代表一个标号，一个标号指代了一个地址。

最终这个段的名称最终将被编译、连接程序处理为一个段的段地址。



![1571302498378](E:\github\JVM\images\1571302498378.png)



![1571302352161](E:\github\JVM\images\1571302352161.png)



源文件     编译     目标文件     连接      执行文件

test.asm   ->     test.obj     ->     test.exe



连接的作用

![1571302684825](E:\github\JVM\images\1571302684825.png)





谁将可执行文件中的程序装载进入内存并使它运行？程序运行结束后，返回到哪里？



![1571302963161](E:\github\JVM\images\1571302963161.png)



![1571302996489](E:\github\JVM\images\1571302996489.png)

