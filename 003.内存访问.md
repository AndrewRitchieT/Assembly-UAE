## 内存访问

字单元：即存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。

高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。

![1571813548918](.\images\1571813548918.png)

0地址单元中存放的**字节型**数据是多少？20H

0地址字单元中存放的**字型**数据是多少？4E20H

2地址单元中存放的**字节型**数据是多少？12H

2地址字单元中存放的**字型**数据是什么？0012H



例如 20000（4E20H）   起始地址为0的字单元，0号单元是低地址单元20，1号单元是高地址单元4E。



## DS寄存器  和 [address]

CPU要读写内存单元时候，必须给出这个内存单元的地址。

在8086中，内存地址由段地址和偏移地址组成

8086CPU中有一个DS寄存器，通常用来存放要访问数据的段地址。



mov 指令

可完成3种传送

1.将数据直接送入寄存器

2.将一个寄存器的内容送入另一个寄存器

3.将一个内存单元的内容送入另一个寄存器



mov 寄存器名  内存单元地址   

[...]  表示一个内存单元，表示一个内存单元的偏移地址。[address]  表示一个偏移地址为address的内存单元



只有偏移地址不能定位一个内存单元，内存单元的段地址，是在指令执行时，**8086CPU自动取DS中的数据作为内存单元的段地址**

**8086不支持将数据直接送入段寄存器的操作，必须从一个寄存器进行中转。**



mov  al  [0]  

mov指令中[]说明操作对象是一个内存单元，[]中的0说明这个内存单元的偏移地址是0.它的段地址默认放在ds中，指令执行时，8086CPU会自动从ds中取出。



## 字的传送

CPU内部如果是16位，16位可以一次性传递一个字的数据。 AX  推断出一个字的数据，即2个字节的数据

![1571105783575](.\images\1571105783575.png)



## mov指令形式



mov   寄存器  ， 数据

mov   寄存器  ， 寄存器

mov   寄存器  ， 内存单元

mov  内存单元 ， 寄存器

mov  段寄存器 ， 寄存器

mov  寄存器  ，段寄存器

mov  内存单元 ，段寄存器

mov  段寄存器 ，  内存单元



add，sub和mov一样







## 数据段

对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将一组长度为N（N<=64KB）,地址连续，起始地址为16的倍数的内存单元当做专门存储数据的内存空间，从而定义一个数据段



在以前的操作系统中，只能写64k的程序。



如何访问数据段？

将一段内存当做数据段，使我们编程时的一种安排，**用ds存放数据段的段地址**，再根据需要，用相关指令访问数据段中的具体单元



![1571107814021](.\images\1571107814021.png)



mov，add，sub 是具有两个操作对象的指令。jmp是具有一个操作对象的指令。





![1571108441427](.\images\1571108441427.png)

![1571108453308](.\images\1571108453308.png)

CS和IP指明代码段，DS指明数据段，SS:SP指明栈段



## CPU中提供的栈机制



LIFO  后进先出   栈



将一组内存单元 定义为一个段，称为栈段



8086CPU提供相关的指令来以栈的方式方位内存空间。可以将一段内存当做栈来访问



8086CPU提供入栈和出栈指令，最基本的两个是PUSH（入栈） 和POP（出栈）



push ax  表示将寄存器ax中的数据送入栈

pop  ax 表示 从栈顶取出数据送入ax



8086CPU的入栈和出栈都是以**字**为单元进行的

字型数据用两个单元存放，高地址单元存放高8位，低地址单元存放低8位。



CPU如何知道栈顶的位置，在8086CPU中，有两个寄存器，段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。



任意时刻，SS:SP 指向栈顶元素。



PUSH和POP指令执行时，CPU从SS和SP中得到栈顶的地址



PUSH AX 的执行，由以下两步完成

1. **SP=SP-2** , 栈以字节为操作单元，所以减2。SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；

2. 将AX中的内容送入SS:SP指向的内存单元出，SS:SP此时指向新栈顶

   

![1571109321451](.\images\1571109321451.png)



**8086CPU中，入栈时，栈顶从高地址向低地址方向增长**

**8086CPU中，出栈时，栈顶从低地址向高地址方向增长**

![1571112428324](.\images\1571112428324.png)





**8086CPU不保证我们对栈的操作不会超界**，CPU8086只知道栈顶在何处，而不知道我们安排的栈空间有多大。



栈空间也属于内存空间的一部分，它是一段可以一种特殊方式进行访问的内存空间。

push和pop可以在寄存器和内存之间传送数据。



push指令值进行字操作



push  寄存器

pop  寄存器



push  段寄存器

pop   段寄存器



push  内存单元

pop  内存单元



mov  ax，1000H

mov  ds，ax         内存单元的段地址要放在ds中

push  [0]			   将1000,0处的字压入栈中

pop  [2]				 出栈，出栈的数据送入 1000:2





![1571116635761](.\images\1571116635761.png)



**如果是10000H~1000FH 这段空间当做栈，注意：sp的偏移地址应该为0010H**



![1571815922530](.\images\1571815922530.png)





执行push时，CPU的两步操作是：先改变SP，后向SS:SP处传送。执行POP时，CPU的两步操作是：先读取SS:SP处的数据，后改变SP。



## 栈段

将长度为N(N<=64KB)的一组地址连续，起始地址为16的倍数的内存单元，当作栈空间来用，从而定义了一个栈段。



如果将10000H~1FFFFH这段空间当作栈段，初始状态栈是空的，此时SS=1000H，SP=？

栈最底部的字单元的地址为1000:FFFE，SP为FFFEH，加2后SP=0，所以当栈为空的时候，SS=1000H，SP=0000H



一个栈段最大可以设置为多少？

偏移地址SP的变化范围为：0~FFFFH，当以栈满的时候，SP又变为0，所以一个栈段容量最大为64KB

寄存器是16位的。所以是FFFFH。 一个FF是一个8位，也就是一个字节。FFFFH为一个字。



## 段综述

![1571119921732](.\images\1571119921732.png)

![1571119995008](.\images\1571119995008.png)



