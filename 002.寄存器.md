## 寄存器

典型的CPU由运算器，控制器，寄存器等器件组成

内部总线实现CPU内部器件的联系，外部总线实现CPU和主板上其他器件的联系。

1. 运算器进行信息处理
2. 寄存器进行信息存储
3. 控制器控制器件工作
4. 内部总线连接各个器件，传递数据

寄存器是CPU中汇编程序员可以用指令读写的部件。

程序员通过改变各种寄存器中的内容来实现对CPU的控制。

8086CPU有14个寄存器，每个寄存器有一个名称：

AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW



8086CPU的所有寄存器都是16位，可以存放两个字节。

AX BX CX DX 这四个寄存器用来存放一般性的数据。称为通用寄存器



通用寄存器

![1571020584241](E:\github\Assembly\images\1571020584241.png)

 

为了兼容上一代CPU中8位寄存器，8086CPU的4个通用寄存器可以分为8个可独立使用的8位寄存器来用。



AX  =  AH  AL

BX  =  BH  BL

CX  =  CH  CL

DX  =  DH  DL 



![1571020770300](E:\github\Assembly\images\1571020770300.png)



十进制数20000  的  存储情况



![1571020868970](E:\github\Assembly\images\1571020868970.png)



![1571020805338](E:\github\Assembly\images\1571020805338.png)



兼容器的考虑：8086可以一次性处理以下两种尺寸的数据

字节：记为byte，一个字节8个bit。可以存在8位寄存器中。

字：记为word，一个字由两个字节组成，这个两个字节分别称为这个字的高位字节和地位字节。





计算题

![1571021422809](E:\github\Assembly\images\1571021422809.png)



![1571021442956](E:\github\Assembly\images\1571021442956.png)

![1571021461933](E:\github\Assembly\images\1571021461933.png)



相加的值为1044CH，进位不能再AX中报错，超过8086的16位寄存器大小



![1571021490570](E:\github\Assembly\images\1571021490570.png)

相加的结果为158H，al为8位寄存器，将最高位去掉后，是真正存入的数据0058H。此时的进位并没有丢弃，只是不能在该寄存器中存放。al和ah是不相干的寄存器，不要错误的认为，注入add al ,93H 的指令产生的进位会存储在ah中。add al，93H  进行的是8 为运算。

如果执行add ax，93H  则需要进位，因为进行的是16位计算。



在进行数据传送或运算时，要注意指令的两个操作对象的位数是一致的。

![1571021854712](E:\github\Assembly\images\1571021854712.png)





16位CPU具有几方面结构特性

运算器一次最多可以处理16位数据

寄存器最大宽度为16位

寄存器和运算器之间的通路为16位



8086外部地址总线为20位，可以传送20位地址，达到1MB寻址能力。8086内部总线为16位。在内部一次性处理，传输，暂时存储的地址为16位，16位可寻址的能力只有64KB。

内部与外部寻址能力不匹配。8086采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。





为什么用20位地址总线？

从硬件看，
　　1、目前32位和64位是指CPU的通用寄存器位宽（数据总线的位宽），所以64位的CPU数据处理位宽是32位CPU的2倍;
　　2、可寻址范围扩展，32位系统支持最大内存位4G（地址总线位宽已经是32位），64位系统理论（地址总线位宽达到64位时）支持最大内存为：2^64=18446,744,073,709,551,616，约1600万TB，相当于16EB。（目前受制于操作系统和主板设计复杂度约束，实际的CPU采取兼容设计，内部地址总线仅使用36~38位（远未不到64位），支持64~256G的内存，以后CPU地址总线逐渐会扩展到用完64位的宽度。

设定20根地址总线是有一定历史原因的。



![1571022966075](E:\github\Assembly\images\1571022966075.png)



![1571023249164](E:\github\Assembly\images\1571023249164.png)



地址加法器采用物理地址=段地址*16+偏移地址



物理地址=基础地址+偏移地址







段的概念

段地址容易让人产生误会，认为内存被划分为段，其实内存并没有分段，段的划分来自有CPU。由于8086CPU用基础地址（段地址*16）+偏移地址=物理地址的方法给出物理地址，使得我们可以用分段的方式来管理内存。

地址  10000H~100FFH的内存单元组成一个段，该段的起始地址为10000H，段地址为1000H，大小为100H。

地址  10000H~1007FH 起始地址  10000H 段地址 1000H  大小 80H

地址   10080H~100FFH 起始地址 10008H 段地址 1008H  大小80H

![1571025394575](E:\github\Assembly\images\1571025394575.png)

偏移地址为16位，寻址能力为64KB，所以，一个段的长度最大为64KB

CPU可以用不同的段地址和偏移地址形成同一个物理地址。

如果给定一个段地址，仅通过变化偏移地址进行寻址，可以定位64KB个内存单元



在8086PC机中，存储单元的地址用两个元素描述，即段地址和偏移地址。

例如数据存在 内存 2000:1F60单元中 或者 数据存在内存的2000H段中的1F60H单元中。





段寄存器

8086在访问内存时要通过段寄存器来提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。

8086CPU有4个段寄存器：CS,DS,SS,ES



CS和IP寄存器

这两个寄存器指示了CPU当前要读取指令的地址，CS为代码段寄存器，IP为指令指针寄存器

假设CS的内容为M，IP中的内容为N，8086CPU从内存M*16+N开始。读取一条指令并执行。

CPU将CS:IP指向的内容当做指令执行。



![1571033964619](E:\github\Assembly\images\1571033964619.png)





![1571034032280](E:\github\Assembly\images\1571034032280.png)





![1571034091505](E:\github\Assembly\images\1571034091505.png)



![1571034111920](E:\github\Assembly\images\1571034111920.png)



![1571034127200](E:\github\Assembly\images\1571034127200.png)



![1571034140806](E:\github\Assembly\images\1571034140806.png)![1571034167241](E:\github\Assembly\images\1571034167241.png)

![1571034183597](E:\github\Assembly\images\1571034183597.png)

![1571034285418](E:\github\Assembly\images\1571034285418.png)



![1571034304741](E:\github\Assembly\images\1571034304741.png)



![1571034326208](E:\github\Assembly\images\1571034326208.png)

8086CPU的工作过程可以简要的描述为

1.从CS:IP 指向的内存单元读取指令，读取的指令进入指令缓冲器

2.IP=IP+所指向的内存单元读取指令，读取的指令进入指令缓冲器

3.执行指令，转到步骤1。重复这个过程。



修改寄存器AX的值，可以用mov指令来完成，但是CS和IP提供了其他指令来改变他们的值，比如说jmp指令。

若想同时修改CS和IP的内容，可用   **jmp 段地址:偏移地址** 指令完成

jmp  2AE3:3  执行后:CS=2AE3H,IP=0003H,CPU将从2AE33H处读取指令

jmp  3:0B16  执行后:CS=0003H,IP=0B16H,CPU将从00B46H处读取指令



若想仅修改IP的内容，可用    jmp 某一合法的寄存器    的指令来完成   类似  mov  IP，ax



jmp  ax  指令执行前：ax=1000H，CS=2000H，IP=0003H

​	           指令执行后：ax=1000H，CS=2000H,   IP=1000H





![1571035979519](E:\github\Assembly\images\1571035979519.png)





![1571036007134](E:\github\Assembly\images\1571036007134.png)



![1571036024990](E:\github\Assembly\images\1571036024990.png)



代码段

我们可以将长度为N（N<=64KB）的一组代码，存在一组地址连续，其实地址为16倍数的内存单元，我们认为这段内存是用来存放代码的。



![1571037017921](E:\github\Assembly\images\1571037017921.png)



通过将CS:IP指向所定义的代码段中的第一条指令的首地址